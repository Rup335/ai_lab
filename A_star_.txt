import heapq

# Moves: up, down, left, right
moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# Goal state
goal = ((1, 2, 3),
        (4, 5, 6),
        (7, 8, 0))

# Check if position is valid
def valid(x, y):
    return 0 <= x < 3 and 0 <= y < 3

# Manhattan distance heuristic
def manhattan(state):
    h = 0
    for i in range(3):
        for j in range(3):
            v = state[i][j]
            if v != 0:
                gi = (v - 1) // 3
                gj = (v - 1) % 3
                h += abs(i - gi) + abs(j - gj)
    return h

# Find blank position
def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

# Generate neighbors
def neighbors(state):
    bx, by = find_blank(state)
    nbrs = []

    for dx, dy in moves:
        nx, ny = bx + dx, by + dy
        if valid(nx, ny):
            new_state = [list(row) for row in state]  # convert to mutable
            new_state[bx][by], new_state[nx][ny] = new_state[nx][ny], new_state[bx][by]
            nbrs.append(tuple(tuple(row) for row in new_state))  # back to tuple

    return nbrs

# A* search
def astar(start):
    pq = []
    heapq.heappush(pq, (manhattan(start), 0, start, [start]))

    visited = set()
    visited.add(start)

    while pq:
        f, g, state, path = heapq.heappop(pq)

        if state == goal:
            print("Solution found in", g, "moves:\n")
            for step in path:
                for row in step:
                    print(row)
                print()
            return

        for n in neighbors(state):
            if n not in visited:
                visited.add(n)
                heapq.heappush(pq, (g + 1 + manhattan(n), g + 1, n, path + [n]))

    print("No solution found")

# Start state that requires minimum 3 steps
start = ((1, 2, 3),
         (4, 0, 6),
         (7, 5, 8))

astar(start)