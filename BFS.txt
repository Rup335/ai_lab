from collections import deque

goal_state = (1, 2, 3,
              4, 5, 6,
              7, 8, 0)

def get_neighbors(state):
    neighbors = []
    idx = state.index(0)
    row = idx // 3
    col = idx % 3

    # up, down, left, right
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dr, dc in moves:
        r = row + dr
        c = col + dc

        if 0 <= r < 3 and 0 <= c < 3:
            new_idx = r * 3 + c
            new_state = list(state)

            # swap
            new_state[idx], new_state[new_idx] = new_state[new_idx], new_state[idx]

            neighbors.append(tuple(new_state))

    return neighbors


# BFS code
def bfs(start_state):
    queue = deque([(start_state, [])])
    visited = set()

    while queue:
        state, path = queue.popleft()   # FIFO

        if state == goal_state:
            return path + [state]

        if state not in visited:
            visited.add(state)

            for neighbor in get_neighbors(state):
                queue.append((neighbor, path + [state]))

    return None


start_state = (1, 2, 3,
               4, 0, 6,
               7, 5, 8)

bfs_result = bfs(start_state)

if bfs_result:
    print("BFS steps:", len(bfs_result) - 1)
else:
    print("No solution")